import Const

class EventManager:
    '''
    It coordinate communication between the Model, View, and Controller.
    Model, View, and Controller are all listeners, the EventManager will broadcast an event to them by post()
    '''
    def __init__(self):
        self.listeners = []

    def register_listener(self, listener):
        '''
        Adds a listener to our spam list.
        It will receive Post()ed events through it's notify(event) call.
        '''
        self.listeners.append(listener)

    def unregister_listener(self, listener):
        '''
        Remove a listener from our spam list.
        This is implemented but hardly used.
        Our weak ref spam list will auto remove any listeners who stop existing.
        '''
        pass

    def post(self, event):
        '''
        Post a new event to the message queue.
        It will be broadcast to all listeners.
        '''
        # # this segment use to debug
        # if not (isinstance(event, Event_EveryTick) or isinstance(event, Event_EverySec)):
        #     print( str(event) )
        for listener in self.listeners:
            listener.notify(event)


class BaseEvent:
    '''
    A superclass for any events that might be generated by
    an object and sent to the EventManager.
    '''
    name = 'Generic event'
    def __init__(self):
        pass

    def __str__(self):
        # For Debug
        return self.name


class EventInitialize(BaseEvent):
    name = 'Initialize event'


class EventQuit(BaseEvent):
    name = 'Quit event'


class EventStateChange(BaseEvent):
    name = 'StateChange event'

    def __init__(self, state):
        self.state = state

    def __str__(self):
        return f'{self.name} => StateTo: {self.state}'


class EventEveryTick(BaseEvent):
    name = 'Tick event'


class EventTimesUp(BaseEvent):
    name = "Time's Up event"

class EventToggleFullScreen(BaseEvent):
    name = 'ToggleFullScreen event'

class EventStop(BaseEvent):
    name = 'GameStop event'
    '''
    Game stops and model stage changes to STATE_STOP.
    '''

class EventContinue(BaseEvent):
    name = 'GameContinue event'
    '''
    Game continues and model stage changes to STATE_PLAY
    '''

class EventRestart(BaseEvent):
    name = 'GameContinue event'
    '''
    Game restarts and model stage changes to STATE_MENU.
    '''

class EventPlayerMove(BaseEvent):
    name = 'PlayerMove event'
    '''
    Player decides to move forward or backward.
    '''
    def __init__(self, player_id: int, direction):
        self.player_id = player_id # 0, 1, 2, 3
        self.direction = direction # 1 : frontward, -1 : backward

    def __str__(self):
        return f'{self.name} => player_id {self.player_id} move {self.direction}'

class EventPlayerNoMove(BaseEvent):
    name = 'PlayerNoMove event'
    '''
    Player decides to not move.
    '''
    def __init__(self, player_id: int):
        self.player_id = player_id # 0, 1, 2, 3

class EventPlayerRotate(BaseEvent):
    name = 'PlayerRotate event'
    '''
    Player decides to rotates leftward or rightward.
    '''
    def __init__(self, player_id: int, direction: int):
        self.player_id = player_id # 0, 1, 2, 3
        self.direction = direction # -1 : rotate_left, 1 : rotate_right

    def __str__(self):
        return f'{self.name} => player_id {self.player_id} rotate {self.direction}'

class EventPlayerAttack(BaseEvent):
    name = 'PlayerAttack event'
    '''
    Player decides to attack. This event will emit no matter the attack succeeds or not.
    '''
    def __init__(self, player_id):
        self.player_id = player_id

    def __str__(self):
        return f'{self.name} => player_id {self.player_id} attack'

class EventPlayerAttackSuccess(BaseEvent):
    name = 'PlayerAttackSuccess event'
    '''
    Player decides to attack, and their attack succeeds.
    '''
    def __init__(self, player_id, gun_type):
        self.player_id = player_id
        self.gun_type = gun_type

    def __str__(self):
        return f'{self.name} => player_id {self.player_id} attack successfully with gun {self.gun_type}'

class EventPlayerGetHit(BaseEvent):
    name = 'PlayerGetHit event'
    '''
    Player gets hit by another player.
    '''
    def __init__(self, victim_id, attacker_id):
        self.victim = victim_id
        self.attacker = attacker_id
    
    def __str__(self):
        return f'{self.name} => player_id {self.victim.player_id} get hit by player_id {self.attacker_id}'

class EventPlayerSwitchGun(BaseEvent):
    name = 'PlayerSwitchGun event'
    '''
    Player's gun switches.
    '''
    def __init__(self, player_id, gun_type):
        self.player_id = player_id
        self.gun_type = gun_type

    def __str__(self):
        return f'{self.name} => player_id {self.player_id} switch their gun to {self.gun_type}'

class EventPlayerBuffed(BaseEvent):
    name = 'PlayerBuffed event'
    '''
    Player gets buffed.
    '''
    def __init__(self, player_id, buff_type):
        self.player_id = player_id
        self.buff_type = buff_type

    def __str__(self):
        return f'{self.name} => player_id {self.player_id} get buffed, buff type: {self.buff_type}'

class EventPlayerDead(BaseEvent):
    name = 'PlayerDead event'
    '''
    Player gets killed.
    '''
    def __init__(self, player_id):
        self.player_id = player_id

    def __str__(self):
<<<<<<< HEAD
        return f'{self.name} => player_id {self.player_id} get killed'

class EventPlayerRemove(BaseEvent):
    name = 'PlayerRemove event'
    '''
    Player gets killed.
    '''
    def __init__(self, player_id):
        self.player_id = player_id

    def __str__(self):
        return f'{self.name} => player_id {self.player_id} is out of life'
=======
        return f'{self.name} => player_id {self.player_id} get killed'
>>>>>>> 030ae11 (add: re field and respawning mechanism)
